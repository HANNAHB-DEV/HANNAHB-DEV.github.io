### 동적계획법 6: Knapsack problem

#### Knapsack

- n개의 아이템과 배낭

- 각각의 아이템은 무개 wi와 가격vi를 가짐

- 배낭의 용량 W

- 목적: 배낭의 용량을 초과하지는 않으면서, 가격이 최대가 되는 부분집합

  | i    | vi   | wi   |
  | ---- | ---- | ---- |
  | 1    | 1    | 1    |
  | 2    | 6    | 2    |
  | 3    | 18   | 5    |
  | 4    | 22   | 6    |
  | 5    | 28   | 7    |

  knapsack instance, weight limit W=11

- ex) {1,2,5}는 가격의 합이 35
  {3,4} 가격의 합 50
  {3,5} 가격의 합 46이나 배낭의 용량 초과



#### Greedy

- 가격이 높은 것 부터 선택
- 무게가 가벼운 것부터 선택
- 단위 무게당 가격이 높은 것부터 선택
  1-1, 2-3, 3-3.6, 4-3.66,5-4
  5번을 두개 챙기고 2번을 챙김 but 3,4를 챙기는 게 이득임을 우리는 알고 있음



#### 순환식

- OPT(i) : 아이템 1, 2, ... i로 얻을 수 있는 최대 이득

- 경우 1: 아이템 i를 선택하지 않은 경우

  - OPT(i) = OPT(i-1) (i를 버리는 거니까)

- 경우2: 아이템 i를 선택하는 경우

  - OPT(i)=?

  식을 세울 수 없으므로 보완이 필요함 ▼

- OPT(i,w): 배낭 용량이 w일 때, 아이템 1, 2, ... i로 얻을 수 있는 최대 이득

- 경우 1: 아이템 i를 선택하지 않은 경우

  - OPT(i,w) = OPT(i-1,w) (i를 버리는 거니까)

- 경우2: 아이템 i를 선택하는 경우

  - OPT(i)=OPT(i-1, w-wi)

| OPT(i,w)                                                     |
| ------------------------------------------------------------ |
| if i=0 , 0<br/>if w>wi, OPT(i-1,w)<br />otherwise max{OPT(i-1,w), vi+OPT(i-1,w-wi)} |

#### Bottom up

```
KNAPSACK(n,W,w1,...wn,v1,...,vn)
for w=0 to W
	M[0,w] <- 0

for i=1 to n
	for w=1 to W
	if(wi>w) M[i,w] <- M[i-1,w]
	else M[i,w] <- max{M[i-1,w], vi+M[i-1, w-wi]}
	
return M[n,W]
```

#### 시간복잡도

- 시간복잡도 O(nW)
- 다항시간인가? NO
  입력크기에 대한 다항함수 일때, 이것을 다항시간이라고 한다.
  n은 입력크기(입력을 하기 위한 bit 수)지만, W는 입력의 갯수가 아니라 값 자체라..
  w: logw.. w는 2의 k승이래..